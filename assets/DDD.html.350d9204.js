import{_ as r,Q as o,z as d,A as c,a6 as t,X as e,C as n,T as s,$ as i}from"./framework.9f8afd9b.js";const u="/images/DDD/1.jpg",h="/images/DDD/2.jpg",k="/images/DDD/3.jpg",m="/images/DDD/4.jpg",b="/images/DDD/6.jpg",D="/images/DDD/5.jpg",g="/images/DDD/7.jpg",v="/images/DDD/8.jpg",f="/images/DDD/9.jpg",q="/images/DDD/10.jpg",x="/images/DDD/11.jpg",_="/images/DDD/12.jpg",y="/images/DDD/13.jpg",w="/images/DDD/2023-03-13-11-03-51.png",C="/images/DDD/2023-03-13-11-05-17.png",S="/images/DDD/2023-03-13-15-24-10.png",P="/images/DDD/2023-03-13-15-27-08.png",B="/images/DDD/2023-03-13-15-40-38.png",I="/images/DDD/2023-03-13-15-49-01.png",j="/images/DDD/2023-03-13-15-52-11.png",O="/images/DDD/2023-03-13-15-53-15.png",R="/images/DDD/2023-03-13-15-53-38.png",W="/images/DDD/2023-03-13-15-59-38.png",L="/images/DDD/2023-03-13-16-00-26.png",T="/images/DDD/2023-03-13-16-01-38.png",V="/images/DDD/2023-03-13-16-10-47.png",A="/images/DDD/2023-03-13-16-12-39.png",E="/images/DDD/2023-03-13-16-14-09.png",N="/images/DDD/2023-03-13-16-15-28.png",U="/images/DDD/2023-03-13-18-14-56.png",G="/images/DDD/2023-03-13-19-04-50.png",H="/images/DDD/2023-03-14-09-37-07.png",M="/images/DDD/2023-03-14-10-28-07.png",Q="/images/DDD/2023-03-14-10-31-48.png",z="/images/DDD/2023-03-14-10-44-53.png",J="/images/DDD/2023-03-14-10-48-43.png",K="/images/DDD/2023-03-14-10-50-07.png",X="/images/DDD/2023-03-14-10-57-50.png",$={},F={id:"diff-微服务",tabindex:"-1"};function Y(Z,a){const l=o("RouterLink"),p=o("big");return d(),c("div",null,[a[14]||(a[14]=t('<h1 id="domain-drive-desingn-领域驱动设计" tabindex="-1"><a class="header-anchor" href="#domain-drive-desingn-领域驱动设计" aria-hidden="true">#</a> Domain Drive Desingn 领域驱动设计</h1><h2 id="概览" tabindex="-1"><a class="header-anchor" href="#概览" aria-hidden="true">#</a> 概览</h2><h3 id="what-why" tabindex="-1"><a class="header-anchor" href="#what-why" aria-hidden="true">#</a> What?Why?</h3><ul><li>DDD是完整系统的<strong>设计方法</strong>，一个从战略设计到战术设计的规范。</li><li>DDD适于处理与领域相关的高复杂度业务的产品研发，其能够为产品建立<strong>稳定的领域模型内核</strong>，有利于领域知识的传递与传承。</li><li>DDD思想有利于提高<strong>面向对象设计能力与架构设计能力</strong>。</li><li>DDD强调团队与领域专家的合作，能够帮助建立<strong>沟通良好的团队组织</strong>，构建一致的架构体系。</li><li>DDD与<strong>微服务架构匹配</strong>，新的微服务架构，还是将系统从单体架构演进到微服务架构设计，都可以遵循领域驱动设计的架构原则。</li></ul><h3 id="简述" tabindex="-1"><a class="header-anchor" href="#简述" aria-hidden="true">#</a> 简述</h3><ul><li>DDD是一个开放的设计方法体系</li></ul><blockquote><p>可以引入：用例，敏捷，整洁架构，函数式编程范式等</p></blockquote><p>-- 转变</p><p>基于数据建模 --&gt; 基于领域建模 基于技术设计 --&gt; 面向对象设计</p><p><img src="'+u+'" alt="图片1"></p><h3 id="步骤" tabindex="-1"><a class="header-anchor" href="#步骤" aria-hidden="true">#</a> 步骤</h3><ol><li><p>定问题: 识別出核心领域 (Core Domain) 与子领域 (SubDomain) 并确定领域的边界以及它们之间的关系</p></li><li><p>划范围: 针对问题域, 引入界限上下文 (Bounded Context) 和上下 文映射 (Context Map) 对问题域进行合理的分解 -&gt; 微服务, 分治 可在不同的界限上下文选择不同的架构模式与实现技术栈</p></li><li><p>做方案: 在界限上下文內, 通过分层架构来隔离关注点, 尤其是将领域 实现独立出来, 能够更利于领域模型的单一性与稳定性 领域模型可适配不同的架构模式: 六边形, CQRS等</p></li></ol><h2 id="ddd-none" tabindex="-1"><a class="header-anchor" href="#ddd-none" aria-hidden="true">#</a> DDD None</h2><p>DDD 不是设计准则或规范，更不是架构设计的脚手架</p><blockquote><p>什么内容才是高内聚的, 如何抽象才能做到低耦合?</p></blockquote><blockquote><p>职责如何划分? 为了重用还是独立进化以应对未来的变化?</p></blockquote><blockquote><p>如何分层? 各层之间该如何协作? 各层的依赖该如何解耦?</p></blockquote><p>对设计本质进行思考！</p>',18)),e("h2",F,[a[1]||(a[1]=e("a",{class:"header-anchor",href:"#diff-微服务","aria-hidden":"true"},"#",-1)),a[2]||(a[2]=n(" Diff ")),s(l,{to:"/Cloud/Microservices.html"},{default:i(()=>a[0]||(a[0]=[n("微服务")])),_:1})]),a[15]||(a[15]=t('<ul><li><p>领域驱动设计是针对复杂系统设计的一套软件工程方法 而微服务是一种架构风格</p></li><li><p>两者之间更深入的关系, 主要体现在领域驱动设计中界限上下文与 微服务之间的映射关系</p></li><li><p>假如界限上下文之间需要跨进程通信, 并形成一种零共享架构 则每个界限上下文就成为了一个微服务</p></li><li><p>如何识别和设计微服务? 领域驱动的战略设计恰好可以在一定程度上解决此问题</p></li></ul><h2 id="软件复杂度" tabindex="-1"><a class="header-anchor" href="#软件复杂度" aria-hidden="true">#</a> 软件复杂度</h2><blockquote><p>领域驱动设计的定位就是应对软件开发的复杂度</p></blockquote><h3 id="成因" tabindex="-1"><a class="header-anchor" href="#成因" aria-hidden="true">#</a> 成因</h3><ol><li>规模</li><li>结构</li><li>变化</li></ol><p>结构是决定系统复杂度的关键因素：高性能、高并发、分布式</p><h3 id="解决" tabindex="-1"><a class="header-anchor" href="#解决" aria-hidden="true">#</a> 解决</h3><ol><li>规模</li></ol><blockquote><p>分而治之, 小既是美 (KISS) Unix 设计的哲学 -单一职责, 团结合作.</p></blockquote><ol start="2"><li>结构</li></ol><blockquote><p>清晰直观且易于理解的分层 DIP 隔离业务与技术复杂度</p></blockquote><ol start="3"><li>变化</li></ol><blockquote><p>拥抱变化 只被第一颗子弹击中</p></blockquote><h3 id="隔离" tabindex="-1"><a class="header-anchor" href="#隔离" aria-hidden="true">#</a> 隔离</h3><blockquote><p>隔离业务复杂度与技术复杂度</p></blockquote><p>首要任务就是确认业务逻辑与技术实现1的边界，从而隔离各自的复杂度</p><p><img src="'+h+`" alt="图片2"></p><p>基础设施层-资源库样例</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">OrderRepository</span><span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span>order<span class="token punctuation">&gt;</span></span> <span class="token function">forBuyerId</span><span class="token punctuation">(</span><span class="token class-name">Identity</span> buyerId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Order</span> order<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PlaceOrderService</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Repository</span>
    <span class="token keyword">private</span> <span class="token class-name">OrderRepository</span> orderRepository<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@service</span>
    <span class="token keyword">private</span> <span class="token class-name">OrderValidator</span> orderValidator<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Identity</span> buyerId<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span>orderItem<span class="token punctuation">&gt;</span></span> items<span class="token punctuation">,</span><span class="token class-name">ShippingAddress</span> shipping<span class="token punctuation">,</span> <span class="token class-name">BillingAddress</span> billing<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Order</span> order <span class="token operator">=</span> <span class="token class-name">Order</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>buyerId<span class="token punctuation">,</span> items<span class="token punctuation">,</span> shipping<span class="token punctuation">,</span> billing<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>orderValidator<span class="token punctuation">.</span><span class="token function">isValid</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        orderRepository<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>

    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OrderException</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;Invalid&quot;</span><span class="token punctuation">,</span> buyerId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="切割" tabindex="-1"><a class="header-anchor" href="#切割" aria-hidden="true">#</a> 切割</h3><h4 id="横切" tabindex="-1"><a class="header-anchor" href="#横切" aria-hidden="true">#</a> 横切</h4><blockquote><p>流程切割</p></blockquote><p><img src="`+k+'" alt="图片3"></p><p>微观建模</p><h4 id="纵切" tabindex="-1"><a class="header-anchor" href="#纵切" aria-hidden="true">#</a> 纵切</h4><blockquote><p>业务切割</p></blockquote><p><img src="'+m+'" alt="图片4"></p><p>宏观建模</p><h2 id="solid原则" tabindex="-1"><a class="header-anchor" href="#solid原则" aria-hidden="true">#</a> SOLID原则</h2><blockquote><p>面向对象设计五大原则</p></blockquote><h3 id="srp-单一职责" tabindex="-1"><a class="header-anchor" href="#srp-单一职责" aria-hidden="true">#</a> SRP 单一职责</h3><blockquote><p>就一个软件实体而言，应该仅有一个引起它变化的原因</p></blockquote><p>业务模型应该有行为，否则会造成Service泄露</p><ul><li>判断标准：</li></ul><p>是否一直重复对业务模型的某些属性做重复的操作，这些行为本身是否就应该属于该业务模型，如订单类对总价的计算。</p><p><img src="'+b+'" alt="图片6"></p>',36)),e("p",null,[s(p,null,{default:i(()=>a[3]||(a[3]=[n("变化永远向着依赖的反方向传递")])),_:1})]),a[16]||(a[16]=t('<p><img src="'+D+'" alt="图片5"></p><p>接口耦合，实现解耦。</p><blockquote><p>面向接口编程：永远依靠于更稳定的东西，所以不面向实现。</p></blockquote><h4 id="srp示例" tabindex="-1"><a class="header-anchor" href="#srp示例" aria-hidden="true">#</a> SRP示例</h4><p><img src="'+g+'" alt="图片7"></p><blockquote><p>违背SRP原则</p></blockquote><p><img src="'+v+'" alt="图片8"></p><blockquote><p>proxy模式</p></blockquote><p><img src="'+f+'" alt="图片9"><img src="'+q+'" alt="图片10"></p><h3 id="ocp-开放封闭" tabindex="-1"><a class="header-anchor" href="#ocp-开放封闭" aria-hidden="true">#</a> OCP 开放封闭</h3><blockquote><p>软件实体(类，模块，函数等)应对扩展开放，对修改封闭</p></blockquote><ul><li><p>对扩展开放</p><ul><li>模块的行为可扩展, 可复用性好</li></ul></li><li><p>对修改封闭</p><ul><li>模块的源代码不可被修改, 可维护性好</li></ul></li></ul><p>通过抽象和多态可以很好的实现即开放，又封闭的OCP原则。</p><p><img src="'+x+`" alt="图片11"></p><p>❤️ <strong>注意：OCP不是免费的午餐！</strong></p><pre><code>OCP 可以带来
- 灵活性, 可重用性, 以及可维护性

但是 OCP 的成本也很高
- 对应用中的每个部分进行抽象不是一个好主意
- 只对会频繁交化的部分做出抽象
</code></pre><blockquote><p>可以灵活使用抽象和多态避免if地狱和switch语句</p></blockquote><p>扩展：复杂度守恒：实现功能的复杂度只和功能本身相关</p><blockquote><p>例如反射消除了switch复杂度且带来了反射本身的复杂度</p></blockquote><h3 id="lsp-里氏替换" tabindex="-1"><a class="header-anchor" href="#lsp-里氏替换" aria-hidden="true">#</a> LSP 里氏替换</h3><blockquote><p>所有引用基类的地方必须能透明地使用其子类的对象</p></blockquote><blockquote><p>继承必须保证超类所拥有的性质(property-行为即函数)在子类中仍然成立</p></blockquote><p>property -&gt; 行为 attribute -&gt; 属性</p><ul><li><p>白盒复用</p><p>有任何接口和行为变化都会影响</p></li><li><p>黑盒复用 有任何借口变化才会影响</p></li></ul><blockquote><p>继承不是好的复用代码的方式，优先使用组合而不是继承</p></blockquote><h4 id="is-a" tabindex="-1"><a class="header-anchor" href="#is-a" aria-hidden="true">#</a> IS-A</h4><p>继承应该是行为一致，而不是属性</p><p>从行为的角度看，正方形在<u>特定实现</u>不是矩形</p><h4 id="契约式设计" tabindex="-1"><a class="header-anchor" href="#契约式设计" aria-hidden="true">#</a> 契约式设计</h4><ul><li><p>前置条件 (Pre-Condition):</p><ul><li>前置条件必须为 &quot;true&quot; 方法才能执行</li></ul></li><li><p>后置条件 (Post-Condition):</p><ul><li>方法执行完成之后, 后置条件必须为 &quot;true&quot;</li></ul></li><li><p>正确使用继承的标准</p><ul><li>Pre-Conditions: Derived Class &lt;= Base Class</li></ul></li></ul><p>(子类前提条件不强于基类</p><pre><code>- Post-Conditions: Derived Class =&gt; Base Class
</code></pre><p>(子类后置条件不弱于量类</p><p><img src="`+_+'" alt="图片12"></p><p>绿色-子类 红色-子类</p><p><img src="'+y+`" alt="图片13"></p><h3 id="isp-接口隔离" tabindex="-1"><a class="header-anchor" href="#isp-接口隔离" aria-hidden="true">#</a> ISP 接口隔离</h3><h4 id="接口污染" tabindex="-1"><a class="header-anchor" href="#接口污染" aria-hidden="true">#</a> 接口污染</h4><p>一个类实现一个接口却不得不实现一个对其无关的方法</p><pre><code>- 原因：接口中存在部分子类（不是所有子类）需要的方法

- 解决方案：适配器模式
</code></pre><p>如何分离接口（委托）？</p><h4 id="类适配器" tabindex="-1"><a class="header-anchor" href="#类适配器" aria-hidden="true">#</a> 类适配器</h4><blockquote><p>通过多继承，多接口实现（Java），在编译确认的适配器模式</p></blockquote><p><img src="`+w+'" alt=""></p><h4 id="对象适配器" tabindex="-1"><a class="header-anchor" href="#对象适配器" aria-hidden="true">#</a> 对象适配器</h4><blockquote><p>运行时对象的组合</p></blockquote><p><img src="'+C+'" alt=""></p><blockquote><p>在使用类适配器解决ISP时，往往会引发LSP问题</p></blockquote><h4 id="测试驱动开发-tdd" tabindex="-1"><a class="header-anchor" href="#测试驱动开发-tdd" aria-hidden="true">#</a> 测试驱动开发 TDD</h4><blockquote><p>由一个失败的单测开始编写业务代码</p></blockquote><p><img src="'+S+'" alt=""></p><p><img src="'+P+'" alt=""></p><p><img src="'+B+'" alt=""></p><h3 id="dip-依赖倒置" tabindex="-1"><a class="header-anchor" href="#dip-依赖倒置" aria-hidden="true">#</a> DIP 依赖倒置</h3><ul><li>高层模块不应该依赖于低层模块，它们都应该依赖于抽象</li></ul><blockquote><p>High-level modules should not depend on low-level modules.</p></blockquote><blockquote><p>Both should depend on abstractions.</p></blockquote><ul><li>抽象不应该依赖于细节，细节应该依赖于抽象</li></ul><blockquote><p>Abstractions should not depend upon defails.</p></blockquote><blockquote><p>Details should depend upon abstractions.</p></blockquote><ul><li>实施前</li></ul><p><img src="'+I+'" alt=""></p><ul><li>实施后</li></ul><p><img src="'+j+'" alt=""></p><h4 id="dip示例" tabindex="-1"><a class="header-anchor" href="#dip示例" aria-hidden="true">#</a> DIP示例</h4><p><img src="'+O+'" alt=""></p><p><img src="'+R+'" alt=""></p><h4 id="分层" tabindex="-1"><a class="header-anchor" href="#分层" aria-hidden="true">#</a> 分层</h4><ul><li><p>All well structured object-oriented architectures have clearly-defined layers,with each layer providing some coherent set of services though a well-defined and controlled interface.</p><p>-Grady Booch</p></li></ul><blockquote><p>所有结构良好的面向对象架构拥有清晰的分层，每个分层 通过良好定义的接口提供条理分明的一系列服务</p></blockquote><p>分层应该是隔离的！</p><p><img src="'+W+'" alt=""></p><p>上图所示的依赖关系是传递的!没有隔离!</p><p><img src="'+L+'" alt=""></p><h4 id="架构演进" tabindex="-1"><a class="header-anchor" href="#架构演进" aria-hidden="true">#</a> 架构演进</h4><ul><li>传统架构</li></ul><p><img src="'+T+'" alt=""></p><ul><li>领域架构演进</li></ul><p><img src="'+V+'" alt=""></p><p><img src="'+A+'" alt=""></p><p>抽象的接口应该属于高层</p><p><img src="'+E+'" alt=""></p><p><img src="'+N+'" alt=""></p><p>高层拥有接口，底层实现接口</p><h4 id="dependencyresolver" tabindex="-1"><a class="header-anchor" href="#dependencyresolver" aria-hidden="true">#</a> DependencyResolver</h4><ol><li><p>Service Locating</p></li><li><p>依赖注入器</p></li></ol><p><img src="'+U+'" alt=""></p><h2 id="通用语言" tabindex="-1"><a class="header-anchor" href="#通用语言" aria-hidden="true">#</a> 通用语言</h2><p>通用语言用于消除领域专家与开发者之间的沟通失调</p><h3 id="通用语言特性" tabindex="-1"><a class="header-anchor" href="#通用语言特性" aria-hidden="true">#</a> 通用语言特性：</h3><ul><li><code>准确</code> <code>通用</code> <code>高效</code></li><li></li><li><code>不包含</code>任何IT术语</li><li></li><li>只包含<code>术语</code> <code>用例</code></li></ul><p>UML的Use Case图是通用语言的一个简单工具</p><p><img src="'+G+`" alt=""></p><h3 id="术语" tabindex="-1"><a class="header-anchor" href="#术语" aria-hidden="true">#</a> 术语</h3><blockquote><p>定义造成的误解 语言特性</p></blockquote><h3 id="领域行为描述" tabindex="-1"><a class="header-anchor" href="#领域行为描述" aria-hidden="true">#</a> 领域行为描述</h3><ul><li>从领域的角度而非实现角度描述领域行为</li><li>若涉及到领域术语，必须遵循术语表的规范</li><li>强调动词的精确性，符合业务动作在该领域的合理性</li><li>要突出与领域行为有关的领域概，念</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>作为一名Scrum Master,
我希望将Sprint Backlog分配给团队成员
以便于明确Backlog的负责人并跟踪进度。

验收标准：
*被分配的Sprint Backlog没有被关闭
*分配成功后，系统会发送邮件给指定的团队成员
*一个Sprint Backlog只能分配给一个团队成员
*若已有负责人与新的负责人为同一个人，则取消本次分配
*每次对Sprint Backlog的分配都需要保存以便于查询
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="通用语言关键点" tabindex="-1"><a class="header-anchor" href="#通用语言关键点" aria-hidden="true">#</a> 通用语言关键点</h3>`,99)),e("p",null,[s(p,null,{default:i(()=>a[4]||(a[4]=[n("5W2H1E")])),_:1})]),a[17]||(a[17]=t('<ul><li><p>Why</p></li><li><p>What</p></li><li><p>Who</p></li><li><p>When</p></li><li><p>Where</p></li><li><p>How</p></li><li><p>How much</p></li><li><p>Exception</p></li><li><p>Pre-Condition</p></li><li><p>Post-Condition</p></li></ul><p>通用语言包含“<code>术语</code>”和“<code>用例场景</code>”</p><p>“<code>用例场景</code>”可以转化为应用服务代码</p><h3 id="分析模式" tabindex="-1"><a class="header-anchor" href="#分析模式" aria-hidden="true">#</a> 分析模式</h3><p>团队与领域专家的对话必须是一种常态 要让对话变得更加高效的最佳的做法是 在团队中形成一种相对固定的场景分析模式</p><p>这些模式包括但不限于：</p><ul><li><p>用例(Use Case)</p><p><img src="'+H+'" alt=""></p></li><li><p>用户故事(Use Story)</p><p><img src="'+M+'" alt=""></p><p><img src="'+Q+'" alt=""></p></li><li><p>测试驱动开发(Test Driven Development)</p></li></ul><blockquote><p>无中生有的写代码 以一个失败的测试开始</p></blockquote><p>在编写测试方法时，应遵循Given-When-Then模式 Given-When-Then模式体现了TDD对设计的驱动力：</p><ul><li>编写Given时</li></ul><p>“驱动”我们思考被测对象的创建，以及它与其他对象的协作</p><ul><li>当编写When时</li></ul><p>驱动”我们思考被测接口的命名，传入参数，行为方式（命令o查询）</p><ul><li>当编写Then时</li></ul><p>“驱动”我们分析被测接口的返回值</p>',15)),e("p",null,[s(p,null,{default:i(()=>a[5]||(a[5]=[n("以领域专家的自然语言为基础")])),_:1})]),e("p",null,[s(p,null,{default:i(()=>a[6]||(a[6]=[n("加")])),_:1})]),e("p",null,[s(p,null,{default:i(()=>a[7]||(a[7]=[n("开发人员的逻辑性（归纳+演绎)")])),_:1})]),e("p",null,[s(p,null,{default:i(()=>a[8]||(a[8]=[n("加")])),_:1})]),e("p",null,[s(p,null,{default:i(()=>a[9]||(a[9]=[n("专有时间")])),_:1})]),a[18]||(a[18]=t('<h3 id="宏观-战略建模" tabindex="-1"><a class="header-anchor" href="#宏观-战略建模" aria-hidden="true">#</a> 宏观-战略建模</h3><blockquote><p>使用通用语言，精准地划分领域以及处理各个领域之间的关系</p></blockquote><p>需求划分为微服务</p><h2 id="领域" tabindex="-1"><a class="header-anchor" href="#领域" aria-hidden="true">#</a> 领域</h2><blockquote><p>领域一词重在范围与界限</p></blockquote><p>在软件开发里，就代表着要解决的问题的范围与界限 如：电子商务系统就是一个领域</p><h3 id="子域" tabindex="-1"><a class="header-anchor" href="#子域" aria-hidden="true">#</a> 子域</h3><p><code>分而治之</code>是人们应对复杂问题的通用方法</p><p>子域就是<code>领域的分解</code>，是相对较小的问题范围</p><h3 id="类型" tabindex="-1"><a class="header-anchor" href="#类型" aria-hidden="true">#</a> 类型</h3><h4 id="核心域" tabindex="-1"><a class="header-anchor" href="#核心域" aria-hidden="true">#</a> 核心域</h4><blockquote><p>核心竞争力所在的子域</p></blockquote><p>如：销售子域（因人而异</p><h4 id="支撑域" tabindex="-1"><a class="header-anchor" href="#支撑域" aria-hidden="true">#</a> 支撑域</h4><blockquote><p>支持核心域的子域</p></blockquote><p>如：除销售子域以外的其他子域</p><h4 id="通用域" tabindex="-1"><a class="header-anchor" href="#通用域" aria-hidden="true">#</a> 通用域</h4><blockquote><p>服务于整个领域的的子域</p></blockquote><p>如：除销售子域以外的其他子域</p><p><img src="'+z+'" alt=""></p>',20)),e("p",null,[a[11]||(a[11]=n("根据")),s(l,{to:"/DDD.html#SRP"},{default:i(()=>a[10]||(a[10]=[n("SRP")])),_:1}),a[12]||(a[12]=n("对要解决的问题拆分细化"))]),e("p",null,[s(p,null,{default:i(()=>a[13]||(a[13]=[n("领域 = 问题的范围")])),_:1})]),a[19]||(a[19]=t('<h2 id="界限上下文-上下文映射" tabindex="-1"><a class="header-anchor" href="#界限上下文-上下文映射" aria-hidden="true">#</a> 界限上下文/上下文映射</h2><blockquote><p>Bounded Context</p></blockquote><p>Eric Evans用细胞来形容界限上下文 细胞之所以能够存在，是因为细胞膜限定了什么在细胞内，什么在细胞外， 并且确定了什么物质可以通过细胞膜</p><p><img src="'+J+'" alt=""></p><ul><li>细胞代表上下文</li><li>而细胞膜代表了包裹上下文的界限</li><li>载体蛋白代表了上下文的接口</li></ul><h3 id="界限上下文示例" tabindex="-1"><a class="header-anchor" href="#界限上下文示例" aria-hidden="true">#</a> 界限上下文示例</h3><p>界限上下文=Bounded Context</p><ul><li>Bounded → 边界</li><li>Context → 上下文</li></ul><p><img src="'+K+'" alt=""></p><p>动态的业务流程会在边界上进行上下文切换</p><h3 id="what" tabindex="-1"><a class="header-anchor" href="#what" aria-hidden="true">#</a> What</h3><p>DDD中与领域对应的概念是界限上下文</p><p>理论上一个子域，对应一个界限上下文</p><h4 id="界限上下文的含义" tabindex="-1"><a class="header-anchor" href="#界限上下文的含义" aria-hidden="true">#</a> 界限上下文的含义</h4><p>一个单词或句子所出现的环境，此环境会反过来影响它们门的含义。</p><p>“我想静静” &quot;静静是谁？&quot;</p><p>“静静”这个概念有歧义，有两个与上下文相关的含义</p><p>界限上下文最重要的作用之一就是<code>消除歧义</code></p><h3 id="概念歧义" tabindex="-1"><a class="header-anchor" href="#概念歧义" aria-hidden="true">#</a> 概念歧义</h3><blockquote><p>概念相同,用法不同</p></blockquote><p><img src="'+X+'" alt=""></p><h3 id="隔离二义性" tabindex="-1"><a class="header-anchor" href="#隔离二义性" aria-hidden="true">#</a> 隔离二义性</h3><h2 id="架构" tabindex="-1"><a class="header-anchor" href="#架构" aria-hidden="true">#</a> 架构</h2><h2 id="实体-值对象" tabindex="-1"><a class="header-anchor" href="#实体-值对象" aria-hidden="true">#</a> 实体/值对象</h2><h2 id="应用服务-领域服务" tabindex="-1"><a class="header-anchor" href="#应用服务-领域服务" aria-hidden="true">#</a> 应用服务/领域服务</h2><h2 id="领域时间-聚合资源库" tabindex="-1"><a class="header-anchor" href="#领域时间-聚合资源库" aria-hidden="true">#</a> 领域时间 聚合资源库</h2><blockquote><p>本文基于Owen Dai讲解整理，整理不易，转载请注明出处。</p></blockquote>',27))])}const na=r($,[["render",Y],["__file","DDD.html.vue"]]);export{na as default};
